{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar Reporter = require(\"../base/reporter\").Reporter;\n\nvar Buffer = require('safer-buffer').Buffer;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\n\ninherits(DecoderBuffer, Reporter);\nexports.DecoderBuffer = DecoderBuffer;\n\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {\n  if (data instanceof DecoderBuffer) {\n    return true;\n  }\n\n  var isCompatible = typeof data === 'object' && Buffer.isBuffer(data.base) && data.constructor.name === 'DecoderBuffer' && typeof data.offset === 'number' && typeof data.length === 'number' && typeof data.save === 'function' && typeof data.restore === 'function' && typeof data.isEmpty === 'function' && typeof data.readUInt8 === 'function' && typeof data.skip === 'function' && typeof data.raw === 'function';\n  return isCompatible;\n};\n\nDecoderBuffer.prototype.save = function save() {\n  return {\n    offset: this.offset,\n    reporter: Reporter.prototype.save.call(this)\n  };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  var res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);else return this.error(fail || 'DecoderBuffer overrun');\n};\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');\n  var res = new DecoderBuffer(this.base);\n  res._reporterState = this._reporterState;\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n};\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n};\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function (item) {\n      if (!EncoderBuffer.isEncoderBuffer(item)) item = new EncoderBuffer(item, reporter);\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error('Unsupported type: ' + typeof value);\n  }\n}\n\nexports.EncoderBuffer = EncoderBuffer;\n\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {\n  if (data instanceof EncoderBuffer) {\n    return true;\n  }\n\n  var isCompatible = typeof data === 'object' && data.constructor.name === 'EncoderBuffer' && typeof data.length === 'number' && typeof data.join === 'function';\n  return isCompatible;\n};\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out) out = Buffer.alloc(this.length);\n  if (!offset) offset = 0;\n  if (this.length === 0) return out;\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function (item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number') out[offset] = this.value;else if (typeof this.value === 'string') out.write(this.value, offset);else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);\n    offset += this.length;\n  }\n\n  return out;\n};","map":{"version":3,"sources":["/usr/local/lib/node_modules/expo-cli/node_modules/asn1.js/lib/asn1/base/buffer.js"],"names":["inherits","require","Reporter","Buffer","DecoderBuffer","base","options","call","isBuffer","error","offset","length","exports","isDecoderBuffer","data","isCompatible","constructor","name","save","restore","isEmpty","readUInt8","skip","raw","prototype","reporter","res","fail","bytes","_reporterState","slice","EncoderBuffer","value","Array","isArray","map","item","isEncoderBuffer","byteLength","join","out","alloc","forEach","write","copy"],"mappings":"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","sourcesContent":["'use strict';\n\nconst inherits = require('inherits');\nconst Reporter = require('../base/reporter').Reporter;\nconst Buffer = require('safer-buffer').Buffer;\n\nfunction DecoderBuffer(base, options) {\n  Reporter.call(this, options);\n  if (!Buffer.isBuffer(base)) {\n    this.error('Input not Buffer');\n    return;\n  }\n\n  this.base = base;\n  this.offset = 0;\n  this.length = base.length;\n}\ninherits(DecoderBuffer, Reporter);\nexports.DecoderBuffer = DecoderBuffer;\n\nDecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {\n  if (data instanceof DecoderBuffer) {\n    return true;\n  }\n\n  // Or accept compatible API\n  const isCompatible = typeof data === 'object' &&\n    Buffer.isBuffer(data.base) &&\n    data.constructor.name === 'DecoderBuffer' &&\n    typeof data.offset === 'number' &&\n    typeof data.length === 'number' &&\n    typeof data.save === 'function' &&\n    typeof data.restore === 'function' &&\n    typeof data.isEmpty === 'function' &&\n    typeof data.readUInt8 === 'function' &&\n    typeof data.skip === 'function' &&\n    typeof data.raw === 'function';\n\n  return isCompatible;\n};\n\nDecoderBuffer.prototype.save = function save() {\n  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };\n};\n\nDecoderBuffer.prototype.restore = function restore(save) {\n  // Return skipped data\n  const res = new DecoderBuffer(this.base);\n  res.offset = save.offset;\n  res.length = this.offset;\n\n  this.offset = save.offset;\n  Reporter.prototype.restore.call(this, save.reporter);\n\n  return res;\n};\n\nDecoderBuffer.prototype.isEmpty = function isEmpty() {\n  return this.offset === this.length;\n};\n\nDecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {\n  if (this.offset + 1 <= this.length)\n    return this.base.readUInt8(this.offset++, true);\n  else\n    return this.error(fail || 'DecoderBuffer overrun');\n};\n\nDecoderBuffer.prototype.skip = function skip(bytes, fail) {\n  if (!(this.offset + bytes <= this.length))\n    return this.error(fail || 'DecoderBuffer overrun');\n\n  const res = new DecoderBuffer(this.base);\n\n  // Share reporter state\n  res._reporterState = this._reporterState;\n\n  res.offset = this.offset;\n  res.length = this.offset + bytes;\n  this.offset += bytes;\n  return res;\n};\n\nDecoderBuffer.prototype.raw = function raw(save) {\n  return this.base.slice(save ? save.offset : this.offset, this.length);\n};\n\nfunction EncoderBuffer(value, reporter) {\n  if (Array.isArray(value)) {\n    this.length = 0;\n    this.value = value.map(function(item) {\n      if (!EncoderBuffer.isEncoderBuffer(item))\n        item = new EncoderBuffer(item, reporter);\n      this.length += item.length;\n      return item;\n    }, this);\n  } else if (typeof value === 'number') {\n    if (!(0 <= value && value <= 0xff))\n      return reporter.error('non-byte EncoderBuffer value');\n    this.value = value;\n    this.length = 1;\n  } else if (typeof value === 'string') {\n    this.value = value;\n    this.length = Buffer.byteLength(value);\n  } else if (Buffer.isBuffer(value)) {\n    this.value = value;\n    this.length = value.length;\n  } else {\n    return reporter.error('Unsupported type: ' + typeof value);\n  }\n}\nexports.EncoderBuffer = EncoderBuffer;\n\nEncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {\n  if (data instanceof EncoderBuffer) {\n    return true;\n  }\n\n  // Or accept compatible API\n  const isCompatible = typeof data === 'object' &&\n    data.constructor.name === 'EncoderBuffer' &&\n    typeof data.length === 'number' &&\n    typeof data.join === 'function';\n\n  return isCompatible;\n};\n\nEncoderBuffer.prototype.join = function join(out, offset) {\n  if (!out)\n    out = Buffer.alloc(this.length);\n  if (!offset)\n    offset = 0;\n\n  if (this.length === 0)\n    return out;\n\n  if (Array.isArray(this.value)) {\n    this.value.forEach(function(item) {\n      item.join(out, offset);\n      offset += item.length;\n    });\n  } else {\n    if (typeof this.value === 'number')\n      out[offset] = this.value;\n    else if (typeof this.value === 'string')\n      out.write(this.value, offset);\n    else if (Buffer.isBuffer(this.value))\n      this.value.copy(out, offset);\n    offset += this.length;\n  }\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"script"}